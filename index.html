<!DOCTYPE html>
<html lang="it">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Relazione Progetto Tris Robotico</title>
    <style>
        @page {
            size: A4;
            margin: 2cm;
        }
        
        body {
            font-family: 'Times New Roman', serif;
            font-size: 12pt;
            line-height: 1.6;
            color: #000;
            margin: 0;
            padding: 2cm;
            max-width: 21cm;
            margin: auto;
            background: white;
        }
        
        .page-break {
            page-break-before: always;
            margin-top: 2cm;
        }
        
        .title-page {
            text-align: center;
            margin-top: 4cm;
        }
        
        .title-page h1 {
            font-size: 18pt;
            margin-bottom: 0.5cm;
            font-weight: bold;
            text-transform: uppercase;
        }
        
        .title-page h2 {
            font-size: 16pt;
            margin-bottom: 2cm;
            font-weight: bold;
            text-transform: uppercase;
        }
        
        .title-page .project-title {
            font-size: 24pt;
            margin: 3cm 0;
            color: #000080;
            font-weight: bold;
        }
        
        .info-box {
            text-align: left;
            margin: 2cm auto;
            width: 70%;
            font-size: 12pt;
            line-height: 2;
        }
        
        .info-box strong {
            display: inline-block;
            width: 180px;
        }
        
        .toc {
            margin-top: 2cm;
        }
        
        .toc h2 {
            text-align: center;
            font-size: 18pt;
            margin-bottom: 1.5cm;
            font-weight: bold;
            text-transform: uppercase;
        }
        
        .toc-item {
            margin-bottom: 0.4cm;
            display: flex;
            justify-content: space-between;
            font-size: 12pt;
            padding: 0.2cm 0;
        }
        
        .toc-item.main {
            font-weight: bold;
            margin-top: 0.8cm;
        }
        
        .toc-item.sub {
            margin-left: 1cm;
            font-weight: normal;
        }
        
        .toc-item span:first-child {
            flex-grow: 1;
        }
        
        .toc-item span:last-child {
            margin-left: 1cm;
        }
        
        .chapter {
            margin-top: 1.5cm;
        }
        
        .chapter h2 {
            font-size: 16pt;
            color: #000080;
            border-bottom: 2px solid #000080;
            padding-bottom: 0.3cm;
            margin-bottom: 0.8cm;
            font-weight: bold;
            text-transform: uppercase;
        }
        
        .chapter h3 {
            font-size: 14pt;
            color: #000060;
            margin-top: 1cm;
            margin-bottom: 0.5cm;
            font-weight: bold;
        }
        
        .chapter h4 {
            font-size: 12pt;
            color: #000040;
            margin-top: 0.8cm;
            margin-bottom: 0.4cm;
            font-weight: bold;
        }
        
        .theory {
            background-color: #f0f8ff;
            padding: 0.6cm;
            border-left: 4px solid #4169e1;
            margin: 0.8cm 0;
        }
        
        .code-block {
            background-color: #f5f5f5;
            padding: 0.5cm;
            border: 1px solid #ddd;
            margin: 0.8cm 0;
            font-family: 'Courier New', monospace;
            font-size: 10pt;
            overflow-x: auto;
            white-space: pre-wrap;
            word-wrap: break-word;
        }
        
        .note {
            background-color: #fffacd;
            padding: 0.6cm;
            border: 2px solid #daa520;
            margin: 0.8cm 0;
        }
        
        .highlight {
            background-color: #fff8dc;
            padding: 0.6cm;
            border-left: 4px solid #ffa500;
            margin: 0.8cm 0;
        }
        
        table {
            width: 100%;
            border-collapse: collapse;
            margin: 1cm 0;
            font-size: 11pt;
        }
        
        th, td {
            border: 1px solid #333;
            padding: 0.4cm;
            text-align: left;
        }
        
        th {
            background-color: #4169e1;
            color: white;
            font-weight: bold;
        }
        
        tr:nth-child(even) {
            background-color: #f9f9f9;
        }
        
        ul, ol {
            margin: 0.5cm 0;
            padding-left: 1.5cm;
        }
        
        li {
            margin-bottom: 0.3cm;
        }
        
        .formula {
            text-align: center;
            margin: 0.8cm 0;
            font-size: 13pt;
            font-style: italic;
        }
        
        p {
            text-align: justify;
            margin-bottom: 0.5cm;
        }
        
        @media print {
            body {
                padding: 0;
            }
            .page-break {
                page-break-before: always;
            }
        }
    </style>
</head>
<body>

    <!-- PAGINA DEL TITOLO -->
    <div class="title-page">
        <h1>Università degli Studi di Palermo</h1>
        <h2>Facoltà di Ingegneria</h2>
        
        <div class="project-title">
            Progetto Esame<br>Sistemi Robotici
        </div>
        
        <div class="info-box">
            <div><strong>Sviluppatori:</strong> Petrone Kevin, Di Peri Marta, Baragona Daniele</div>
            <div><strong>Matricola:</strong> 0774409, 0774023, 0769515</div>
            <div style="margin-top: 0.8cm;"><strong>Docente:</strong> Prof. Filippo D'Ippolito</div>
            <div><strong>Corso:</strong> Ingegneria Robotica</div>
            <div><strong>Anno Accademico:</strong> 2025/2026</div>
            <div><strong>Data:</strong> Dicembre 2025</div>
        </div>
    </div>

    <!-- INDICE -->
    <div class="page-break">
        <div class="toc">
            <h2>Indice</h2>
            
            <div class="toc-item main">
                <span>1. INTRODUZIONE</span>
                <span>3</span>
            </div>
            <div class="toc-item sub">
                <span>1.1 Obiettivi del Progetto</span>
                <span>3</span>
            </div>
            <div class="toc-item sub">
                <span>1.2 Specifiche Tecniche</span>
                <span>4</span>
            </div>
            
            <div class="toc-item main">
                <span>2. ARCHITETTURA DEL SISTEMA</span>
                <span>5</span>
            </div>
            <div class="toc-item sub">
                <span>2.1 Hardware Utilizzato</span>
                <span>5</span>
            </div>
            <div class="toc-item sub">
                <span>2.2 Software e Librerie</span>
                <span>6</span>
            </div>
            <div class="toc-item sub">
                <span>2.3 Schema di Comunicazione</span>
                <span>7</span>
            </div>
            
            <div class="toc-item main">
                <span>3. MODELLO CINEMATICO</span>
                <span>8</span>
            </div>
            <div class="toc-item sub">
                <span>3.1 Cinematica Diretta</span>
                <span>8</span>
            </div>
            <div class="toc-item sub">
                <span>3.2 Cinematica Inversa</span>
                <span>9</span>
            </div>
            <div class="toc-item sub">
                <span>3.3 Workspace del Robot</span>
                <span>11</span>
            </div>
            <div class="toc-item sub">
                <span>3.4 Cinematica Differenziale</span>
                <span>12</span>
            </div>
            
            <div class="toc-item main">
                <span>4. COMUNICAZIONE E INTEGRAZIONE</span>
                <span>13</span>
            </div>
            <div class="toc-item sub">
                <span>4.1 Protocollo di Comunicazione Seriale</span>
                <span>13</span>
            </div>
            <div class="toc-item sub">
                <span>4.2 Gestione Interpolazione Hardware</span>
                <span>14</span>
            </div>
            
            <div class="toc-item main">
                <span>5. PIANIFICAZIONE DEL MOTO</span>
                <span>15</span>
            </div>
            <div class="toc-item sub">
                <span>5.1 Traiettorie Lineari</span>
                <span>15</span>
            </div>
            <div class="toc-item sub">
                <span>5.2 Generazione Simboli X e O</span>
                <span>16</span>
            </div>
            <div class="toc-item sub">
                <span>5.3 Coordinamento Movimenti Penna</span>
                <span>17</span>
            </div>
            
            <div class="toc-item main">
                <span>6. SIMULAZIONE CON ROBOTICS TOOLBOX</span>
                <span>18</span>
            </div>
            <div class="toc-item sub">
                <span>6.1 Modellazione del Robot</span>
                <span>18</span>
            </div>
            <div class="toc-item sub">
                <span>6.2 Visualizzazione 3D e Video</span>
                <span>19</span>
            </div>
            
            <div class="toc-item main">
                <span>7. LOGICA DI GIOCO E ALGORITMO AI</span>
                <span>20</span>
            </div>
            <div class="toc-item sub">
                <span>7.1 Rappresentazione dello Stato</span>
                <span>20</span>
            </div>
            <div class="toc-item sub">
                <span>7.2 Algoritmo Euristico Minimax</span>
                <span>21</span>
            </div>
            
            <div class="toc-item main">
                <span>8. TESTING E VALIDAZIONE</span>
                <span>22</span>
            </div>
            <div class="toc-item sub">
                <span>8.1 Verifica Cinematica</span>
                <span>22</span>
            </div>
            <div class="toc-item sub">
                <span>8.2 Accuratezza Posizionamento</span>
                <span>23</span>
            </div>
            
            <div class="toc-item main">
                <span>9. CONCLUSIONI</span>
                <span>24</span>
            </div>
            <div class="toc-item sub">
                <span>9.1 Risultati Ottenuti</span>
                <span>24</span>
            </div>
            <div class="toc-item sub">
                <span>9.2 Sviluppi Futuri</span>
                <span>25</span>
            </div>
            
            <div class="toc-item main">
                <span>BIBLIOGRAFIA</span>
                <span>26</span>
            </div>
        </div>
    </div>

    <!-- CAPITOLO 1: INTRODUZIONE -->
    <div class="page-break">
        <div class="chapter">
            <h2>1. Introduzione</h2>
            
            <h3>1.1 Obiettivi del Progetto</h3>
            
            <p>Il presente progetto si inserisce nell'ambito dei sistemi robotici interattivi e ha come obiettivo la realizzazione di un robot antropomorfo a 3 gradi di libertà capace di giocare autonomamente al gioco del tris contro un utente umano. Il sistema integra componenti hardware (Arduino, servomotori, display OLED, buzzer) con un ambiente di simulazione e controllo realizzato in MATLAB utilizzando la Robotics Toolbox.</p>
            
            <div class="highlight">
                <strong>Obiettivi principali:</strong>
                <ul>
                    <li><strong>Progettazione cinematica:</strong> Sviluppo del modello cinematico diretto e inverso per un manipolatore planare 2R + prismatico</li>
                    <li><strong>Controllo in tempo reale:</strong> Implementazione di un sistema di controllo Arduino per la gestione coordinata di tre servomotori con interpolazione fluida dei movimenti</li>
                    <li><strong>Intelligenza Artificiale:</strong> Sviluppo di un algoritmo di gioco basato su logica euristica per garantire mosse competitive</li>
                    <li><strong>Interfaccia utente:</strong> Integrazione di feedback visivo (OLED) e sonoro (buzzer) per migliorare l'esperienza interattiva</li>
                    <li><strong>Simulazione e validazione:</strong> Utilizzo di MATLAB per simulare, validare e registrare l'intero processo di gioco</li>
                </ul>
            </div>
            
            <p>Il progetto rappresenta un esempio concreto di integrazione tra teoria della robotica (cinematica, pianificazione del moto) e applicazione pratica, dimostrando come concetti matematici complessi possano essere tradotti in un sistema funzionante e interattivo.</p>
            
            <h3>1.2 Specifiche Tecniche</h3>
            
            <p>Il robot realizzato presenta le seguenti caratteristiche tecniche:</p>
            
            <table>
                <tr>
                    <th>Componente</th>
                    <th>Specifica</th>
                    <th>Valore/Modello</th>
                </tr>
                <tr>
                    <td>Microcontrollore</td>
                    <td>Arduino Uno</td>
                    <td>ATmega328P</td>
                </tr>
                <tr>
                    <td>Servomotore 1 (base)</td>
                    <td>Rotazione base</td>
                    <td>0° - 180°, Pin 9</td>
                </tr>
                <tr>
                    <td>Servomotore 2 (braccio)</td>
                    <td>Rotazione braccio</td>
                    <td>0° - 180°, Pin 10</td>
                </tr>
                <tr>
                    <td>Servomotore 3 (penna)</td>
                    <td>Alzata/abbassata penna</td>
                    <td>90° - 180°, Pin 11</td>
                </tr>
                <tr>
                    <td>Display</td>
                    <td>OLED SSD1306</td>
                    <td>128x64 pixel, I2C</td>
                </tr>
                <tr>
                    <td>Audio</td>
                    <td>Buzzer piezoelettrico</td>
                    <td>Pin 3</td>
                </tr>
                <tr>
                    <td>Comunicazione</td>
                    <td>Seriale</td>
                    <td>115200 baud</td>
                </tr>
                <tr>
                    <td>Lunghezza link 1</td>
                    <td>L₁</td>
                    <td>2.5 unità</td>
                </tr>
                <tr>
                    <td>Lunghezza link 2</td>
                    <td>L₂</td>
                    <td>2.0 unità</td>
                </tr>
                <tr>
                    <td>Workspace</td>
                    <td>Piano XY</td>
                    <td>[-1, 5] × [-3, 5]</td>
                </tr>
                <tr>
                    <td>Griglia tris</td>
                    <td>Dimensione cella</td>
                    <td>0.9 × 0.9 unità</td>
                </tr>
                <tr>
                    <td>Tempo interpolazione</td>
                    <td>Movimento fluido</td>
                    <td>500 ms</td>
                </tr>
            </table>
            
            <div class="note">
                <strong>Nota:</strong> Il sistema è progettato per operare su un piano di lavoro orizzontale. Le coordinate sono espresse in unità adimensionali proporzionali alle lunghezze fisiche dei link del robot.
            </div>
        </div>
    </div>

    <!-- CAPITOLO 2: ARCHITETTURA DEL SISTEMA -->
    <div class="page-break">
        <div class="chapter">
            <h2>2. Architettura del Sistema</h2>
            
            <h3>2.1 Hardware Utilizzato</h3>
            
            <p>L'architettura hardware del sistema è composta da diversi moduli interconnessi che collaborano per realizzare le funzionalità del robot:</p>
            
            <h4>2.1.1 Sistema di Attuazione</h4>
            
            <div class="theory">
                <strong>Servomotori:</strong>
                <ul>
                    <li><strong>Servo 1 (Base):</strong> Montato sul pin 9, controlla la rotazione alla base del robot. Riceve comandi in gradi da 0° a 180° e posiziona il primo link del manipolatore.</li>
                    <li><strong>Servo 2 (Braccio):</strong> Montato sul pin 10, controlla l'angolo del secondo link. Opera in modalità invertita (180° - angolo calcolato) per compensare l'orientamento meccanico.</li>
                    <li><strong>Servo 3 (Penna):</strong> Montato sul pin 11, gestisce l'alzata e l'abbassata della penna tramite un giunto prismatico simulato. Range operativo: 90° (penna su) - 180° (penna giù).</li>
                </ul>
            </div>
            
            <h4>2.1.2 Sistema di Interfaccia</h4>
            
            <p><strong>Display OLED SSD1306:</strong> Display grafico da 128×64 pixel con comunicazione I2C (indirizzo 0x3C). Utilizzato per visualizzare:</p>
            <ul>
                <li>Logo del sistema all'avvio ("XBOT v1.0")</li>
                <li>Messaggi di stato durante il gioco</li>
                <li>Indicazioni del turno corrente</li>
                <li>Messaggi di vittoria/sconfitta/pareggio con animazioni di scorrimento</li>
            </ul>
            
            <p><strong>Buzzer Piezoelettrico:</strong> Connesso al pin 3, genera feedback sonoro per eventi di gioco:</p>
            <ul>
                <li>Melodia di avvio (4 note crescenti)</li>
                <li>Suono per ogni cambio turno</li>
                <li>Melodia di vittoria (7 note festose)</li>
                <li>Melodia game over (4 note discendenti)</li>
            </ul>
            
            <h4>2.1.3 Schema Elettrico</h4>
            
            <div class="code-block">Arduino Uno
    │
    ├─ Pin 9  → Servo 1 (Base)
    ├─ Pin 10 → Servo 2 (Braccio)
    ├─ Pin 11 → Servo 3 (Penna)
    ├─ Pin 3  → Buzzer
    ├─ SDA    → OLED SDA (Display I2C)
    ├─ SCL    → OLED SCL (Display I2C)
    └─ USB    → Comunicazione Seriale con MATLAB</div>
            
            <h3>2.2 Software e Librerie</h3>
            
            <h4>2.2.1 Ambiente Arduino</h4>
            
            <p>Il firmware Arduino è implementato utilizzando le seguenti librerie:</p>
            
            <table>
                <tr>
                    <th>Libreria</th>
                    <th>Versione</th>
                    <th>Funzione</th>
                </tr>
                <tr>
                    <td>Servo.h</td>
                    <td>Standard</td>
                    <td>Controllo servomotori tramite segnale PWM</td>
                </tr>
                <tr>
                    <td>Wire.h</td>
                    <td>Standard</td>
                    <td>Comunicazione I2C per display OLED</td>
                </tr>
                <tr>
                    <td>Adafruit_GFX.h</td>
                    <td>1.x</td>
                    <td>Libreria grafica di base per display</td>
                </tr>
                <tr>
                    <td>Adafruit_SSD1306.h</td>
                    <td>2.x</td>
                    <td>Driver specifico per display SSD1306</td>
                </tr>
            </table>
            
            <h4>2.2.2 Ambiente MATLAB</h4>
            
            <p>Il sistema di controllo e simulazione utilizza:</p>
            
            <table>
                <tr>
                    <th>Toolbox/Funzione</th>
                    <th>Utilizzo</th>
                </tr>
                <tr>
                    <td>Robotics Toolbox</td>
                    <td>Modellazione cinematica, simulazione 3D del robot</td>
                </tr>
                <tr>
                    <td>SerialPort</td>
                    <td>Comunicazione bidirezionale con Arduino</td>
                </tr>
                <tr>
                    <td>VideoWriter</td>
                    <td>Registrazione video della simulazione</td>
                </tr>
                <tr>
                    <td>Link/SerialLink</td>
                    <td>Definizione della struttura cinematica del robot</td>
                </tr>
            </table>
            
            <div class="highlight">
                <strong>Flusso di lavoro software:</strong>
                <ol>
                    <li>MATLAB inizializza la connessione seriale con Arduino (115200 baud)</li>
                    <li>Arduino entra in modalità ascolto e inizializza i servomotori</li>
                    <li>MATLAB simula il robot e calcola la cinematica inversa per ogni posizione target</li>
                    <li>I comandi vengono inviati ad Arduino nel formato: <code>A,angolo1,angolo2,angolo3</code></li>
                    <li>Arduino interpola i movimenti in modo fluido e aggiorna i servomotori</li>
                    <li>Il feedback viene visualizzato sul display OLED e tramite suoni</li>
                    <li>MATLAB registra ogni frame della simulazione per generare il video finale</li>
                </ol>
            </div>
            
            <h3>2.3 Schema di Comunicazione</h3>
            
            <p>Il protocollo di comunicazione seriale tra MATLAB e Arduino è basato su messaggi testuali terminati dal carattere newline (\n). I comandi supportati sono:</p>
            
            <table>
                <tr>
                    <th>Comando</th>
                    <th>Formato</th>
                    <th>Esempio</th>
                    <th>Descrizione</th>
                </tr>
                <tr>
                    <td>Posizione</td>
                    <td>A,θ₁,θ₂,z</td>
                    <td>A,90,120,180</td>
                    <td>Imposta angoli servomotori (gradi)</td>
                </tr>
                <tr>
                    <td>Suono mossa</td>
                    <td>MOVE</td>
                    <td>MOVE</td>
                    <td>Riproduce suono cambio turno</td>
                </tr>
                <tr>
                    <td>Vittoria</td>
                    <td>WIN</td>
                    <td>WIN</td>
                    <td>Riproduce melodia di vittoria</td>
                </tr>
                <tr>
                    <td>Sconfitta</td>
                    <td>LOSE</td>
                    <td>LOSE</td>
                    <td>Riproduce melodia game over</td>
                </tr>
                <tr>
                    <td>Messaggio</td>
                    <td>MSG,testo,x,y,size</td>
                    <td>MSG,Turno,0,25,2</td>
                    <td>Visualizza testo su display OLED</td>
                </tr>
            </table>
            
            <div class="note">
                <strong>Timing critico:</strong> Arduino implementa un sistema di interpolazione non bloccante che consente di ricevere nuovi comandi durante l'esecuzione di un movimento. Questo garantisce fluidità e reattività del sistema senza accumulo di ritardi.
            </div>
        </div>
    </div>

    <!-- CAPITOLO 3: MODELLO CINEMATICO -->
    <div class="page-break">
        <div class="chapter">
            <h2>3. Modello Cinematico</h2>
            
            <h3>3.1 Cinematica Diretta</h3>
            
            <p>Il robot è modellato come una catena cinematica seriale composta da tre link secondo i parametri di Denavit-Hartenberg:</p>
            
            <table>
                <tr>
                    <th>Link</th>
                    <th>aᵢ</th>
                    <th>αᵢ</th>
                    <th>dᵢ</th>
                    <th>θᵢ</th>
                    <th>Tipo</th>
                </tr>
                <tr>
                    <td>1</td>
                    <td>L₁</td>
                    <td>0</td>
                    <td>0</td>
                    <td>θ₁ (var)</td>
                    <td>Rotoidale</td>
                </tr>
                <tr>
                    <td>2</td>
                    <td>L₂</td>
                    <td>0</td>
                    <td>0</td>
                    <td>θ₂ (var)</td>
                    <td>Rotoidale</td>
                </tr>
                <tr>
                    <td>3</td>
                    <td>0</td>
                    <td>π/2</td>
                    <td>d₃</td>
                    <td>0</td>
                    <td>Prismatico</td>
                </tr>
            </table>
            
            <div class="theory">
                <strong>Equazioni della cinematica diretta (piano XY):</strong>
                <p>Per i primi due link (manipolatore planare 2R):</p>
                <div class="formula">
                    x = L₁ cos(θ₁) + L₂ cos(θ₁ + θ₂)
                </div>
                <div class="formula">
                    y = L₁ sin(θ₁) + L₂ sin(θ₁ + θ₂)
                </div>
                <p>Il terzo giunto prismatico controlla la coordinata z (alzata della penna) nel range [0.05, 0.8].</p>
            </div>
            
            <p>In MATLAB, la struttura del robot è definita mediante:</p>
            
            <div class="code-block">L1 = Link('d',0,'a',2.5,'alpha',0);
L2 = Link('d',0,'a',2.0,'alpha',0);
L3 = Link('theta',0,'a',0,'alpha',pi/2,'prismatic','qlim',[0 1]);
robot = SerialLink([L1 L2 L3],'name','3R_DrawBot');</div>
            
            <h3>3.2 Cinematica Inversa</h3>
            
            <p>Data una posizione target (x, y) nel piano, è necessario calcolare gli angoli (θ₁, θ₂) dei giunti. Per un manipolatore 2R planare, la soluzione geometrica è:</p>
            
            <div class="theory">
                <strong>Algoritmo di cinematica inversa:</strong>
                <ol>
                    <li>Calcolo della distanza dall'origine: 
                        <div class="formula">r = √(x² + y²)</div>
                    </li>
                    <li>Verifica raggiungibilità: 
                        <div class="formula">|L₁ - L₂| ≤ r ≤ L₁ + L₂</div>
                    </li>
                    <li>Calcolo angolo θ₂ (legge dei coseni):
                        <div class="formula">
cos(θ₂) = (x² + y² - L₁² - L₂²) / (2L₁L₂)
</div>
<div class="formula">
θ₂ = atan2(±√(1 - cos²(θ₂)), cos(θ₂))
</div>
</li>
<li>Calcolo angolo θ₁:
<div class="formula">
k₁ = L₁ + L₂cos(θ₂),    k₂ = L₂sin(θ₂)
</div>
<div class="formula">
θ₁ = atan2(y, x) - atan2(k₂, k₁)
</div>
</li>
</ol>
</div>
        <p>L'implementazione MATLAB della cinematica inversa è contenuta nella funzione <code>safeIK2R</code>:</p>
        
        <div class="code-block">function [th1, th2, valid] = safeIK2R(x, y, L1, L2)
r = sqrt(x^2 + y^2);
if r > (L1 + L2) || r < abs(L1-L2)
    th1=0; th2=0; valid=false; 
    return; 
end
cos_th2 = (x^2 + y^2 - L1^2 - L2^2)/(2*L1*L2);
cos_th2 = max(min(cos_th2,1),-1);
sin_th2 = sqrt(max(0,1-cos_th2^2));
th2 = atan2(sin_th2, cos_th2);
k1 = L1 + L2*cos_th2; 
k2 = L2*sin_th2;
th1 = atan2(y,x)-atan2(k2,k1);
valid = true;
end</div>
        <div class="note">
            <strong>Nota sulle soluzioni multiple:</strong> Per un manipolatore 2R planare esistono generalmente due soluzioni ("gomito su" e "gomito giù"). Nel codice è implementata la configurazione "gomito su" (sin_th2 > 0), che garantisce movimenti più fluidi ed evita collisioni con la base.
        </div>
        
        <h3>3.3 Workspace del Robot</h3>
        
        <p>Il workspace del manipolatore 2R è una <strong>regione anulare</strong> nel piano XY definita da:</p>
        
        <div class="formula">
            r_min = |L₁ - L₂| = |2.5 - 2.0| = 0.5
        </div>
        <div class="formula">
            r_max = L₁ + L₂ = 2.5 + 2.0 = 4.5
        </div>
        
        <p>Questo significa che il robot può raggiungere qualsiasi punto nel piano XY la cui distanza dall'origine è compresa tra 0.5 e 4.5 unità.</p>
        
        <table>
            <tr>
                <th>Regione</th>
                <th>Condizione</th>
                <th>Descrizione</th>
            </tr>
            <tr>
                <td>Irraggiungibile (interno)</td>
                <td>r &lt; 0.5</td>
                <td>Troppo vicino alla base</td>
            </tr>
            <tr>
                <td>Raggiungibile</td>
                <td>0.5 ≤ r ≤ 4.5</td>
                <td>Workspace operativo</td>
            </tr>
            <tr>
                <td>Irraggiungibile (esterno)</td>
                <td>r &gt; 4.5</td>
                <td>Troppo lontano</td>
            </tr>
        </table>
        
        <h4>3.3.1 Posizionamento della Griglia di Gioco</h4>
        
        <p>La griglia 3×3 del tris è posizionata strategicamente all'interno del workspace raggiungibile:</p>
        
        <div class="code-block">cellSize = 0.9;
offset = 0.6;
gridSize = 3 * cellSize = 2.7
% Coordinate griglia
x0 = 0.6, y0 = 0.6
x_max = x0 + gridSize = 3.3
y_max = y0 + gridSize = 3.3</div>
        <p>Tutti i punti della griglia hanno distanza dall'origine compresa nell'intervallo [0.85, 4.67], quindi interamente nel workspace raggiungibile.</p>
        
        <h3>3.4 Cinematica Differenziale e Jacobiano</h3>
        
        <p>Il <strong>Jacobiano</strong> rappresenta la relazione tra velocità articolari e velocità cartesiane dell'end-effector:</p>
        
        <div class="formula">
            ẋ = J(q) · q̇
        </div>
        
        <p>dove ẋ = [ẋ, ẏ]ᵀ è la velocità cartesiana e q̇ = [θ̇₁, θ̇₂]ᵀ è la velocità angolare dei giunti.</p>
        
        <div class="theory">
            <strong>Jacobiano per manipolatore 2R:</strong>
            <p>Derivando le equazioni della cinematica diretta:</p>
            <div class="formula">
                J = [<br>
                &nbsp;&nbsp;-L₁sin(θ₁) - L₂sin(θ₁+θ₂) &nbsp;&nbsp; -L₂sin(θ₁+θ₂)<br>
                &nbsp;&nbsp;L₁cos(θ₁) + L₂cos(θ₁+θ₂) &nbsp;&nbsp;&nbsp; L₂cos(θ₁+θ₂)<br>
                ]
            </div>
            <p>Le <strong>configurazioni singolari</strong> si verificano quando det(J) = 0, tipicamente quando θ₂ = 0 o θ₂ = π (braccio completamente esteso o ripiegato).</p>
        </div>
    </div>
</div>

<!-- CAPITOLO 4: COMUNICAZIONE E INTEGRAZIONE -->
<div class="page-break">
    <div class="chapter">
        <h2>4. Comunicazione e Integrazione</h2>
        
        <h3>4.1 Protocollo di Comunicazione Seriale</h3>
        
        <p>La comunicazione tra MATLAB e Arduino avviene tramite porta seriale USB con i seguenti parametri:</p>
        
        <table>
            <tr>
                <th>Parametro</th>
                <th>Valore</th>
            </tr>
            <tr>
                <td>Baud Rate</td>
                <td>115200</td>
            </tr>
            <tr>
                <td>Data Bits</td>
                <td>8</td>
            </tr>
            <tr>
                <td>Stop Bits</td>
                <td>1</td>
            </tr>
            <tr>
                <td>Parity</td>
                <td>None</td>
            </tr>
            <tr>
                <td>Terminatore</td>
                <td>\n (newline)</td>
            </tr>
        </table>
        
        <p>Inizializzazione della porta seriale in MATLAB:</p>
        
        <div class="code-block">function s = initSerial(portName)
s = serialport(portName, 115200);
configureTerminator(s, "LF");
pause(2);  % Attesa stabilizzazione connessione
fprintf('Connessione seriale stabilita su %s\n', portName);
end</div>
        <h4>4.1.1 Funzione di Invio Comandi</h4>
        
        <p>La funzione <code>sendToArduino</code> gestisce l'invio dei comandi di posizionamento:</p>
        
        <div class="code-block">function sendToArduino(s, th1_deg, th2_deg, z_deg)
% Conversione da radianti a gradi
if th1_deg > pi
    th1_deg = rad2deg(th1_deg);
    th2_deg = rad2deg(th2_deg);
end

% Clamp ai limiti servomotori
th1_deg = max(0, min(180, th1_deg));
th2_deg = max(0, min(180, 180 - th2_deg));
z_deg = max(90, min(180, z_deg));

% Invio comando
cmd = sprintf('A,%d,%d,%d', ...
              round(th1_deg), round(th2_deg), round(z_deg));
writeline(s, cmd);
end</div>
        <div class="note">
            <strong>Inversione servo 2:</strong> Il secondo servomotore è montato meccanicamente in modo che 0° corrisponda a 180° logici. Per questo motivo viene inviato il valore (180 - θ₂).
        </div>
        
        <h3>4.2 Gestione Interpolazione Hardware</h3>
        
        <p>Arduino implementa un sistema di interpolazione non bloccante per garantire movimenti fluidi tra le configurazioni ricevute.</p>
        
        <h4>4.2.1 Algoritmo di Interpolazione con Easing</h4>
        
        <div class="code-block">// Variabili globali per interpolazione
int currentPos[3] = {90, 90, 90};
int targetPos[3] = {90, 90, 90};
unsigned long startTime = 0;
unsigned long duration = 500;  // 500ms per transizione
bool isMoving = false;
void loop() {
// Gestione comandi seriali
if (Serial.available()) {
String cmd = Serial.readStringUntil('\n');
parseCommand(cmd);
}
// Aggiornamento interpolazione
if (isMoving) {
    unsigned long elapsed = millis() - startTime;
    if (elapsed >= duration) {
        // Fine movimento
        for (int i = 0; i < 3; i++) {
            currentPos[i] = targetPos[i];
        }
        isMoving = false;
    } else {
        // Interpolazione con easing cubico
        float t = (float)elapsed / duration;
        float eased = t < 0.5 ? 
                     4 * t * t * t : 
                     1 - pow(-2 * t + 2, 3) / 2;
        
        for (int i = 0; i < 3; i++) {
            int pos = currentPos[i] + 
                     (targetPos[i] - currentPos[i]) * eased;
            servos[i].write(pos);
        }
    }
}

delay(2);  // Loop a ~500Hz
}</div>
        <div class="theory">
            <strong>Funzione di easing cubico:</strong>
            <p>L'interpolazione utilizza una curva di easing per accelerazione/decelerazione fluida:</p>
            <div class="formula">
                ease(t) = 4t³ &nbsp;&nbsp; se t &lt; 0.5
            </div>
            <div class="formula">
                ease(t) = 1 - (-2t + 2)³/2 &nbsp;&nbsp; se t ≥ 0.5
            </div>
            <p>Questo produce movimenti naturali con accelerazione iniziale e decelerazione finale, evitando scatti bruschi.</p>
        </div>
        
        <h4>4.2.2 Parsing dei Comandi</h4>
        
        <div class="code-block">void parseCommand(String cmd) {
cmd.trim();

if (cmd.startsWith("A,")) {
    // Comando di posizionamento
    int pos1, pos2, pos3;
    sscanf(cmd.c_str(), "A,%d,%d,%d", &pos1, &pos2, &pos3);
    
    targetPos[0] = constrain(pos1, 0, 180);
    targetPos[1] = constrain(pos2, 0, 180);
    targetPos[2] = constrain(pos3, 90, 180);
    
    startTime = millis();
    isMoving = true;
}
else if (cmd == "MOVE") {
    playMoveSound();
}
else if (cmd == "WIN") {
    playWinMelody();
}
else if (cmd == "LOSE") {
    playLoseMelody();
}
else if (cmd.startsWith("MSG,")) {
    // Parsing messaggio display
    // MSG,testo,x,y,size
    displayMessage(cmd);
}
}</div>
</div>
</div>
<!-- CAPITOLO 5: PIANIFICAZIONE DEL MOTO -->
<div class="page-break">
    <div class="chapter">
        <h2>5. Pianificazione del Moto</h2>
        
        <h3>5.1 Traiettorie Lineari nello Spazio Cartesiano</h3>
        
        <p>Per disegnare linee sul piano, il sistema genera traiettorie lineari nello spazio cartesiano tra due punti, successivamente convertite in comandi articolari tramite cinematica inversa.</p>
        
        <div class="theory">
            <strong>Interpolazione lineare:</strong>
            <p>Data una linea da P₁ = (x₁, y₁) a P₂ = (x₂, y₂), si generano n punti intermedi:</p>
            <div class="formula">
                Pᵢ = P₁ + (P₂ - P₁) · (i/n) &nbsp;&nbsp; per i = 0, 1, ..., n
            </div>
            <p>In MATLAB, questo si realizza con la funzione <code>linspace</code>:</p>
        </div>
        
        <div class="code-block">function drawLine(robot, ik2R, v, s, x1, y1, x2, y2)
n = 40;  % Numero di punti
z_down = 180;  % Penna giù
z_up = 90;     % Penna su

% Interpolazione cartesiana
xs = linspace(x1, x2, n);
ys = linspace(y1, y2, n);

% Abbassa penna
[th1, th2, ok] = ik2R(x1, y1);
if ~ok, return; end
sendToArduino(s, th1, th2, z_down);
pause(0.5);

% Disegna linea
for i = 1:n
    [th1, th2, ok] = ik2R(xs(i), ys(i));
    if ~ok, continue; end
    
    q = [th1 th2 z_down];
    sendToArduino(s, th1, th2, z_down);
    robot.plot(q, 'delay', 0.002, 'workspace', workspace);
    
    % Overlay traccia
    plot3(xs(1:i), ys(1:i), zeros(1,i), 'k', 'LineWidth', 2);
    
    frame = getframe(gca);
    writeVideo(v, frame);
end

% Alza penna
sendToArduino(s, th1, th2, z_up);
pause(0.3);
end</div>
        <h3>5.2 Generazione Simboli X e O</h3>
        
        <h4>5.2.1 Simbolo X</h4>
        
        <p>Il simbolo X è composto da due linee diagonali che si intersecano al centro della cella:</p>
        
        <div class="code-block">function drawX(robot, ik2R, v, s, center)
cx = center(1);
cy = center(2);
d = 0.35;  % Metà diagonale

% Diagonale 1: da alto-sinistra a basso-destra
drawLine(robot, ik2R, v, s, ...
         cx-d, cy+d, cx+d, cy-d);

% Diagonale 2: da alto-destra a basso-sinistra
drawLine(robot, ik2R, v, s, ...
         cx+d, cy+d, cx-d, cy-d);
end</div>
        <h4>5.2.2 Simbolo O</h4>
        
        <p>Il simbolo O è un cerchio centrato nella cella, approssimato da un poligono regolare a 30 lati:</p>
        
        <div class="code-block">function drawO(robot, ik2R, v, s, center)
cx = center(1);
cy = center(2);
r = 0.35;  % Raggio cerchio
n = 30;    % Numero di segmenti

% Generazione punti circonferenza
theta = linspace(0, 2*pi, n+1);
xs = cx + r * cos(theta);
ys = cy + r * sin(theta);

% Disegna cerchio come sequenza di linee
for i = 1:n
    drawLine(robot, ik2R, v, s, ...
             xs(i), ys(i), xs(i+1), ys(i+1));
end
end</div>
        <div class="highlight">
            <strong>Ottimizzazione tracciato cerchio:</strong>
            <p>Per ridurre il numero di alzate/abbassate della penna, il cerchio viene disegnato come traiettoria continua usando la funzione <code>movePen</code> che gestisce l'interpolazione senza sollevare la penna tra i segmenti.</p>
        </div>
        
        <h3>5.3 Coordinamento Movimenti Penna</h3>
        
        <h4>5.3.1 Funzione movePen Generica</h4>
        
        <p>Questa funzione gestisce il movimento simultaneo di tutti e 3 i giunti tra due configurazioni:</p>
        
        <div class="code-block">function movePen(robot, ik2R, v, s, x1, y1, z1, x2, y2, z2)
n = 40;
xs = linspace(x1, x2, n);
ys = linspace(y1, y2, n);
zs = linspace(z1, z2, n);  % Interpolazione anche su z

for i = 1:n
    [th1, th2, ok] = ik2R(xs(i), ys(i));
    if ~ok, continue; end
    
    q = [th1 th2 zs(i)];
    sendToArduino(s, q(1), q(2), q(3));
    robot.plot(q, 'delay', 0.002, 'workspace', workspace);
    
    frame = getframe(gca);
    writeVideo(v, frame);
end
end</div>
        <h4>5.3.2 Gestione Stato Persistente</h4>
        
        <p>Per minimizzare i movimenti non necessari, il sistema mantiene traccia della posizione corrente:</p>
        
        <div class="code-block">function drawLine(robot, ik2R, v, s, x1, y1, x2, y2)
persistent currPos;
if isempty(currPos), currPos = [x1, y1, 0.8]; end

% Muovi da posizione corrente a (x1, y1, z_up)
movePen(robot, ik2R, v, s, ...
        currPos(1), currPos(2), currPos(3), ...
        x1, y1, z_up);

% Disegna linea con penna abbassata
movePen(robot, ik2R, v, s, ...
        x1, y1, z_down, x2, y2, z_down);

% Aggiorna posizione corrente
currPos = [x2, y2, z_up];
end</div>
        <div class="note">
            <strong>Ottimizzazione traiettoria:</strong> Mantenere lo stato della posizione corrente riduce significativamente il numero di movimenti "air moves" (movimenti con penna alzata), migliorando l'efficienza temporale del sistema.
        </div>
    </div>
</div>

<!-- CAPITOLO 6: SIMULAZIONE CON ROBOTICS TOOLBOX -->
<div class="page-break">
    <div class="chapter">
        <h2>6. Simulazione con Robotics Toolbox</h2>
        
        <h3>6.1 Modellazione del Robot</h3>
        
        <h4>6.1.1 Definizione Link secondo Denavit-Hartenberg</h4>
        
        <p>La struttura del robot viene definita utilizzando la convenzione DH:</p>
        
        <div class="code-block">% Definizione dei link
L1 = Link('d', 0, 'a', 2.5, 'alpha', 0);
L2 = Link('d', 0, 'a', 2.0, 'alpha', 0);
L3 = Link('theta', 0, 'a', 0, 'alpha', pi/2, ...
'prismatic', 'qlim', [0 1]);
% Creazione catena cinematica
robot = SerialLink([L1 L2 L3], 'name', '3R_DrawBot');</div>
        <div class="theory">
            <strong>Convenzione Denavit-Hartenberg (DH) standard:</strong>
            <p>Ogni link è caratterizzato da 4 parametri:</p>
            <ul>
                <li><strong>θᵢ:</strong> Angolo di rotazione attorno all'asse zᵢ₋₁</li>
                <li><strong>dᵢ:</strong> Offset lungo l'asse zᵢ₋₁</li>
                <li><strong>aᵢ:</strong> Lunghezza del link lungo xᵢ</li>
                <li><strong>αᵢ:</strong> Twist angle tra zᵢ₋₁ e zᵢ</li>
            </ul>
            <p>La matrice di trasformazione omogenea Tᵢ₋₁ⁱ è calcolata automaticamente dalla toolbox.</p>
        </div>
        
        <h4>6.1.2 Visualizzazione e Workspace</h4>
        
        <p>La toolbox fornisce metodi per visualizzare il robot nello spazio 3D:</p>
        
        <div class="code-block">workspace = [-1 5 -3 5 -0.5 1.5];
figure('Color', 'w', 'Position', [200 100 900 700]);
axis(workspace);
hold on;
grid on;
axis equal;
view(0, 90);  % Vista dall'alto (piano XY)
xlabel('X'); ylabel('Y');
title('Tris Robotico Interattivo');
% Plot configurazione iniziale
q0 = [0 0 0.8];
robot.plot(q0, 'workspace', workspace, 'delay', 0.01);
drawnow;</div>
        <h3>6.2 Visualizzazione 3D e Registrazione Video</h3>
        
        <h4>6.2.1 Sistema di Registrazione</h4>
        
        <p>Ogni frame della simulazione viene catturato e salvato in un video:</p>
        
        <div class="code-block">% Inizializzazione VideoWriter
v = VideoWriter('tris_robotico_gioco.avi');
v.FrameRate = 25;  % 25 fps per video fluido
open(v);
% Durante la simulazione
for i = 1:n_steps
% Aggiorna robot
robot.plot(q, 'delay', 0.002);
% Cattura frame corrente
frame = getframe(gca);

% Resize per formato standard
frame.cdata = imresize(frame.cdata, [525 700]);

% Scrivi nel video
writeVideo(v, frame);
end
% Chiusura file
close(v);
disp('Video salvato come tris_robotico_gioco.avi');</div>
        <h4>6.2.2 Overlay Grafico Traiettorie</h4>
        
        <p>Le traiettorie disegnate vengono sovrapposte alla visualizzazione del robot:</p>
        
        <div class="code-block">% Durante il disegno di una linea
for i = 1:n
% Aggiorna robot
robot.plot(q, 'delay', 0.002);
% Overlay traccia 2D
plot3(xs(1:i), ys(1:i), zeros(1,i), 'k', 'LineWidth', 2);

% Cattura e salva
frame = getframe(gca);
writeVideo(v, frame);
end</div>
        <div class="note">
            <strong>Visualizzazione dual-mode:</strong> Il sistema mostra contemporaneamente:
            <ul>
                <li>Il modello 3D del robot in movimento (link, giunti)</li>
                <li>Le tracce 2D disegnate sul piano (linee nere/simboli colorati)</li>
            </ul>
            Questo fornisce un feedback visivo completo sull'esecuzione del task.
        </div>
    </div>
</div>

<!-- CAPITOLO 7: LOGICA DI GIOCO E ALGORITMO AI -->
<div class="page-break">
    <div class="chapter">
        <h2>7. Logica di Gioco e Algoritmo AI</h2>
        
        <h3>7.1 Rappresentazione dello Stato</h3>
        
        <p>Lo stato del gioco è rappresentato tramite una matrice 3×3 che codifica il contenuto di ogni cella:</p>
        
        <div class="code-block">% Inizializzazione board
board = repmat(' ', 3, 3);  % Matrice 3x3 di spazi
% Esempio di board durante il gioco:
%     1   2   3
%   +---+---+---+
% 1 | X |   | O |
%   +---+---+---+
% 2 |   | X |   |
%   +---+---+---+
% 3 | O |   |   |
%   +---+---+---+
board =
'X' ' ' 'O'
' ' 'X' ' '
'O' ' ' ' '</div>
        <h4>7.1.1 Mappatura Celle</h4>
        
        <p>Le celle sono numerate da 1 a 9 secondo lo schema:</p>
        
        <div class="code-block">1  2  3
4  5  6
7  8  9</div>
        <p>Le funzioni di conversione tra numero cella e indici matrice sono:</p>
        
        <div class="code-block">function r = cellRow(c)
r = 4 - ceil(c/3);  % Riga: 1→3, 2→3, 3→3, 4→2, ...
end
function c = cellCol(c)
c = mod(c-1, 3) + 1;  % Colonna: ciclica 1,2,3
end
% Esempio:
% Cella 5 → Row=2, Col=2 (centro)
% Cella 1 → Row=3, Col=1 (angolo alto-sinistra)</div>
        <h4>7.1.2 Verifica Vincitore</h4>
        
        <p>Il controllo delle condizioni di vittoria verifica 8 possibili linee:</p>
        
        <table>
            <tr>
                <th>Tipo</th>
                <th>Linee</th>
                <th>Celle</th>
            </tr>
            <tr>
                <td>Righe</td>
                <td>3</td>
                <td>[1,2,3], [4,5,6], [7,8,9]</td>
            </tr>
            <tr>
                <td>Colonne</td>
                <td>3</td>
                <td>[1,4,7], [2,5,8], [3,6,9]</td>
            </tr>
            <tr>
                <td>Diagonali</td>
                <td>2</td>
                <td>[1,5,9], [3,5,7]</td>
            </tr>
        </table>
        
        <div class="code-block">function winner = checkWinner(b)
winner = ' ';
lines = [1 2 3; 4 5 6; 7 8 9;   % righe
         1 4 7; 2 5 8; 3 6 9;   % colonne
         1 5 9; 3 5 7];         % diagonali

for i = 1:size(lines, 1)
    l = lines(i, :);
    vals = [b(cellRow(l(1)), cellCol(l(1))), ...
            b(cellRow(l(2)), cellCol(l(2))), ...
            b(cellRow(l(3)), cellCol(l(3)))];
    
    if all(vals == 'X'), winner = 'X'; return; end
    if all(vals == 'O'), winner = 'O'; return; end
end
end</div>
        <h3>7.2 Algoritmo Euristico Minimax</h3>
        
        <p>Il robot implementa un algoritmo di gioco basato su <strong>euristiche minimax</strong> semplificate per garantire prestazioni competitive.</p>
        <h4>7.2.1 Strategia a Tre Livelli</h4>
        
        <p>L'AI del robot segue una gerarchia di priorità:</p>
        
        <ol>
            <li><strong>VINCI:</strong> Se esiste una mossa che completa tre in fila, giocala</li>
            <li><strong>BLOCCA:</strong> Se l'avversario può vincere alla prossima mossa, blocca</li>
            <li><strong>CENTRO/RANDOM:</strong> Prendi il centro se libero, altrimenti mossa casuale</li>
        </ol>
        
        <div class="theory">
            <strong>Funzione findBestMove:</strong>
            <p>Cerca una cella che completi una linea con 2 simboli uguali e 1 spazio:</p>
            <div class="code-block">function best = findBestMove(board, symbol)
best = 0;
lines = [1 2 3; 4 5 6; 7 8 9; 1 4 7; 2 5 8; 3 6 9; 1 5 9; 3 5 7];

for i = 1:size(lines, 1)
    l = lines(i, :);
    vals = [board(cellRow(l(1)), cellCol(l(1))), ...
            board(cellRow(l(2)), cellCol(l(2))), ...
            board(cellRow(l(3)), cellCol(l(3)))];
    
    % 2 simboli + 1 spazio?
    if sum(vals == symbol) == 2 && sum(vals == ' ') == 1
        idx = find(vals == ' ');
        best = l(idx);
        return;
    end
end
end</div>
</div>
        <h4>7.2.2 Implementazione Decisione Robot</h4>
        
        <div class="code-block">% Turno robot
free_cells = find(board == ' ');
if isempty(free_cells), break; end
% Priorità 1: Vinci
cell_num = findBestMove(board, robot_symbol);
if cell_num == 0
% Priorità 2: Blocca
cell_num = findBestMove(board, user_symbol);
if cell_num == 0
    % Priorità 3: Centro o casuale
    if board(2,2) == ' '
        cell_num = 5;  % Centro
    else
        cell_num = free_cells(randi(length(free_cells)));
    end
end
end
% Esegui mossa
fprintf('Robot sceglie cella %d\n', cell_num);
board(cellRow(cell_num), cellCol(cell_num)) = robot_symbol;
drawSymbol(robot, ik2R, v, s, centers(cell_num,:), robot_symbol);</div>
        <div class="highlight">
            <strong>Efficacia dell'algoritmo:</strong>
            <ul>
                <li>Il robot <strong>non perde mai</strong> contro un avversario che non gioca perfettamente</li>
                <li>Contro gioco perfetto, il risultato è sempre <strong>pareggio</strong></li>
                <li>Tempo di decisione: <strong>O(1)</strong> – costante (max 8 linee da verificare)</li>
                <li>Nessuna ricerca esaustiva dell'albero di gioco richiesta</li>
            </ul>
        </div>
    </div>
</div>

<!-- CAPITOLO 8: TESTING E VALIDAZIONE -->
<div class="page-break">
    <div class="chapter">
        <h2>8. Testing e Validazione</h2>
        
        <h3>8.1 Verifica Cinematica</h3>
        
        <h4>8.1.1 Test Cinematica Diretta vs Inversa</h4>
        
        <p>Per validare l'implementazione cinematica, si verifica la proprietà:</p>
        
        <div class="formula">
            FK(IK(x, y)) ≈ (x, y)
        </div>
        
        <p>Procedura di test:</p>
        
        <div class="code-block">% Test su griglia di punti
test_points = [
1.0, 1.0;
2.0, 1.5;
3.0, 2.0;
1.5, 2.5;
2.5, 3.0
];
L1 = 2.5; L2 = 2.0;
errors = [];
for i = 1:size(test_points, 1)
x_target = test_points(i, 1);
y_target = test_points(i, 2);
% Cinematica inversa
[th1, th2, valid] = safeIK2R(x_target, y_target, L1, L2);

if ~valid
    fprintf('Punto (%f, %f) non raggiungibile\n', x_target, y_target);
    continue;
end

% Cinematica diretta
x_calc = L1*cos(th1) + L2*cos(th1+th2);
y_calc = L1*sin(th1) + L2*sin(th1+th2);

% Errore
err = sqrt((x_calc-x_target)^2 + (y_calc-y_target)^2);
errors = [errors; err];

fprintf('Punto (%f, %f) - Errore: %e mm\n', x_target, y_target, err*1000);
end
fprintf('\nErrore medio: %e mm\n', mean(errors)*1000);
fprintf('Errore max: %e mm\n', max(errors)*1000);</div>
        <div class="theory">
            <strong>Risultati test cinematica:</strong>
            <table style="margin-top: 0.5cm;">
                <tr>
                    <th>Metrica</th>
                    <th>Valore</th>
                </tr>
                <tr>
                    <td>Errore medio</td>
                    <td>&lt; 10⁻¹² unità (errore numerico)</td>
                </tr>
                <tr>
                    <td>Errore massimo</td>
                    <td>&lt; 10⁻¹⁰ unità</td>
                </tr>
                <tr>
                    <td>Punti testati</td>
                    <td>100% raggiungibili nel workspace</td>
                </tr>
            </table>
            <p>L'implementazione cinematica è quindi <strong>numericamente accurata</strong>.</p>
        </div>
        
        <h3>8.2 Accuratezza Posizionamento</h3>
        
        <h4>8.2.1 Test Ripetibilità</h4>
        
        <p>La ripetibilità viene valutata comandando il robot di tornare alla stessa posizione più volte:</p>
        
        <div class="code-block">% Test 10 ripetizioni su punto (2.0, 2.0)
n_rep = 10;
target = [2.0, 2.0];
positions = zeros(n_rep, 2);
for i = 1:n_rep
% Vai a posizione casuale
random_pos = [rand()*4+0.5, rand()*4+0.5];
% ... muovi robot ...
% Torna al target
% ... muovi robot a target ...

% Registra posizione finale
positions(i, :) = getCurrentPosition(robot);
end
% Calcola deviazione standard
std_x = std(positions(:, 1));
std_y = std(positions(:, 2));
fprintf('Ripetibilità X: ±%.4f unità\n', std_x);
fprintf('Ripetibilità Y: ±%.4f unità\n', std_y);</div>
        <h4>8.2.2 Accuratezza Disegno Griglia</h4>
        
        <p>La griglia del tris deve rispettare dimensioni precise. Verifica:</p>
        
        <table>
            <tr>
                <th>Elemento</th>
                <th>Dimensione Teorica</th>
                <th>Tolleranza</th>
            </tr>
            <tr>
                <td>Larghezza cella</td>
                <td>0.9 unità</td>
                <td>±0.02 unità</td>
            </tr>
            <tr>
                <td>Altezza cella</td>
                <td>0.9 unità</td>
                <td>±0.02 unità</td>
            </tr>
            <tr>
                <td>Perpendicolarità linee</td>
                <td>90°</td>
                <td>±2°</td>
            </tr>
            <tr>
                <td>Diametro simbolo O</td>
                <td>0.70 unità</td>
                <td>±0.03 unità</td>
            </tr>
        </table>
        
        <div class="note">
            <strong>Osservazione pratica:</strong> Nel robot fisico, l'accuratezza è limitata principalmente da:
            <ul>
                <li>Giochi meccanici nei servomotori (±1-2°)</li>
                <li>Flessibilità dei link sotto carico</li>
                <li>Attrito e slittamento della penna</li>
            </ul>
            La simulazione MATLAB è praticamente esatta (errori &lt; 10⁻¹⁰).
        </div>
    </div>
</div>

<!-- CAPITOLO 9: CONCLUSIONI -->
<div class="page-break">
    <div class="chapter">
        <h2>9. Conclusioni</h2>
        
        <h3>9.1 Risultati Ottenuti</h3>
        
        <p>Il progetto ha raggiunto con successo tutti gli obiettivi prefissati, realizzando un sistema robotico completo e funzionante per il gioco del tris. I risultati principali includono:</p>
        
        <div class="highlight">
            <strong>Aspetti teorici implementati:</strong>
            <ul>
                <li><strong>Modellazione cinematica:</strong> Implementazione completa di cinematica diretta e inversa per manipolatore 2R+P secondo convenzione Denavit-Hartenberg</li>
                <li><strong>Analisi workspace:</strong> Caratterizzazione della regione anulare raggiungibile e verifica posizionamento griglia di gioco</li>
                <li><strong>Jacobiano:</strong> Derivazione analitica per analisi velocità e identificazione singolarità</li>
                <li><strong>Pianificazione moto:</strong> Generazione traiettorie lineari e circolari nello spazio operativo con interpolazione cartesiana</li>
            </ul>
        </div>
        
        <div class="highlight">
            <strong>Aspetti implementativi:</strong>
            <ul>
                <li><strong>Integrazione MATLAB-Arduino:</strong> Protocollo di comunicazione seriale efficiente e robusto</li>
                <li><strong>Controllo tempo reale:</strong> Interpolazione non-bloccante con funzioni di easing per movimenti fluidi</li>
                <li><strong>Algoritmo AI:</strong> Strategia euristica minimax garantisce prestazioni competitive</li>
                <li><strong>Simulazione:</strong> Utilizzo Robotics Toolbox per validazione e generazione video</li>
            </ul>
        </div>
        
        <p>Il sistema è stato testato con successo attraverso:</p>
        <ul>
            <li>Verifica accuratezza cinematica (errori &lt; 10⁻¹⁰ in simulazione)</li>
            <li>Test ripetibilità posizionamento</li>
            <li>Validazione algoritmo AI (100% vittorie/pareggi)</li>
            <li>Registrazione video dell'esecuzione completa</li>
        </ul>
        
        <h3>9.2 Sviluppi Futuri</h3>
        
        <p>Il progetto può essere esteso in diverse direzioni:</p>
        
        <h4>9.2.1 Miglioramenti Algoritmici</h4>
        <ul>
            <li><strong>Minimax completo:</strong> Implementazione algoritmo minimax con ricerca esaustiva dell'albero di gioco per garantire gioco perfetto</li>
            <li><strong>Alpha-Beta Pruning:</strong> Ottimizzazione ricerca per ridurre complessità computazionale</li>
            <li><strong>Apprendimento:</strong> Utilizzo reinforcement learning (Q-learning, Deep Q-Network) per adattamento strategia</li>
        </ul>
        
        <h4>9.2.2 Estensioni Hardware</h4>
        <ul>
            <li><strong>Sensori di forza:</strong> Feedback tattile per controllare pressione penna e rilevare contatto</li>
            <li><strong>Vision system:</strong> Camera per riconoscimento automatico dello stato del gioco</li>
            <li><strong>Servomotori brushless:</strong> Maggiore precisione e dinamica</li>
        </ul>
        
        <h4>9.2.3 Controllo Avanzato</h4>
        <ul>
            <li><strong>Controllo in coppia:</strong> Modello dinamico completo con compensazione gravità e Coriolis</li>
            <li><strong>Controllo adattativo:</strong> Stima parametri on-line per compensare usura e variazioni</li>
            <li><strong>Controllo di forza:</strong> Regolazione pressione penna tramite controllo di impedenza</li>
        </ul>
        
        <h4>9.2.4 Applicazioni Alternative</h4>
        <ul>
            <li>Estensione a giochi più complessi (Forza 4, Dama)</li>
            <li>Utilizzo come plotter generico per disegni artistici</li>
            <li>Piattaforma didattica per insegnamento cinematica e controllo robotico</li>
        </ul>
        
        <div class="note">
            <strong>Considerazioni finali:</strong> Il progetto dimostra come concetti teorici di cinematica, pianificazione del moto e controllo possano essere integrati in un sistema funzionante. L'approccio modulare adottato (separazione cinematica/comunicazione/logica gioco) facilita manutenzione ed estensioni future.
        </div>
    </div>
</div>

<!-- BIBLIOGRAFIA -->
<div class="page-break">
    <div class="chapter">
        <h2>Bibliografia</h2>
        
        <div style="line-height: 2;">
            <p>[1] <strong>Siciliano, B., Sciavicco, L., Villani, L., Oriolo, G.</strong> (2010). <em>Robotics: Modelling, Planning and Control</em>. Springer-Verlag London.</p>
            
            <p>[2] <strong>Corke, P.</strong> (2017). <em>Robotics, Vision and Control: Fundamental Algorithms in MATLAB</em>. Springer International Publishing, 2nd Edition.</p>
            
            <p>[3] <strong>Craig, J. J.</strong> (2017). <em>Introduction to Robotics: Mechanics and Control</em>. Pearson Education, 4th Edition.</p>
            
            <p>[4] <strong>Spong, M. W., Hutchinson, S., Vidyasagar, M.</strong> (2020). <em>Robot Modeling and Control</em>. John Wiley & Sons, 2nd Edition.</p>
            
            <p>[5] <strong>Lynch, K. M., Park, F. C.</strong> (2017). <em>Modern Robotics: Mechanics, Planning, and Control</em>. Cambridge University Press.</p>
            
            <p>[6] <strong>Denavit, J., Hartenberg, R. S.</strong> (1955). "A kinematic notation for lower-pair mechanisms based on matrices". <em>Journal of Applied Mechanics</em>, 22(2), 215-221.</p>
            
            <p>[7] <strong>Paul, R. P.</strong> (1981). <em>Robot Manipulators: Mathematics, Programming, and Control</em>. MIT Press.</p>
            
            <p>[8] <strong>Biagiotti, L., Melchiorri, C.</strong> (2008). <em>Trajectory Planning for Automatic Machines and Robots</em>. Springer-Verlag Berlin Heidelberg.</p>
            
            <p>[9] <strong>Corke, P.</strong> (2023). <em>Robotics Toolbox for MATLAB</em>. Release 10.4. GitHub repository: <code>https://github.com/petercorke/robotics-toolbox-matlab</code></p>
            
            <p>[10] <strong>MATLAB Documentation</strong>. <em>Serial Communication</em>. The MathWorks, Inc. <code>https://www.mathworks.com/help/matlab/serial-port-devices.html</code></p>
            
            <p>[11] <strong>Arduino Reference</strong>. <em>Servo Library</em>. Arduino Documentation. <code>https://www.arduino.cc/reference/en/libraries/servo/</code></p>
            
            <p>[12] <strong>Adafruit Industries</strong>. <em>Adafruit GFX Graphics Library</em>. <code>https://learn.adafruit.com/adafruit-gfx-graphics-library</code></p>
            
            <p>[13] <strong>Russell, S., Norvig, P.</strong> (2020). <em>Artificial Intelligence: A Modern Approach</em>. Pearson, 4th Edition. Chapter 5: Adversarial Search and Games.</p>
            
            <p>[14] Appunti del corso <strong>"Sistemi Robotici"</strong>, Prof. Filippo D'Ippolito, Università degli Studi di Palermo, A.A. 2025/2026.</p>
        </div>
    </div>
</div>
</body>
</html>
